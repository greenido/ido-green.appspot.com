<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pull-Ups Challenge Tracker</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons (CDN alternative) -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- MediaPipe for pose detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        
        // Icon components (using Lucide icons)
        const Camera = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                <circle cx={12} cy={13} r={3} />
            </svg>
        );

        const Plus = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <line x1={12} y1={5} x2={12} y2={19} strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} />
                <line x1={5} y1={12} x2={19} y2={12} strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} />
            </svg>
        );

        const Minus = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <line x1={5} y1={12} x2={19} y2={12} strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} />
            </svg>
        );

        const Users = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
        );

        const Trophy = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z" />
            </svg>
        );

        const Play = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <polygon points="5,3 19,12 5,21" strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} />
            </svg>
        );

        const Pause = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <rect x={6} y={4} width={4} height={16} strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} />
                <rect x={14} y={4} width={4} height={16} strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} />
            </svg>
        );

        const RefreshCw = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M1 4v6h6M23 20v-6h-6" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15" />
            </svg>
        );

        const Video = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
            </svg>
        );

        const Download = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
        );

        function PullUpTracker() {
            const [players, setPlayers] = useState([]);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
            const [isTracking, setIsTracking] = useState(false);
            const [showCamera, setShowCamera] = useState(false);
            const [cameraError, setCameraError] = useState('');
            const [hasPermission, setHasPermission] = useState(false);
            const [isDetecting, setIsDetecting] = useState(false);
            const [detectionStatus, setDetectionStatus] = useState('');
            const [pullUpState, setPullUpState] = useState('down'); // 'down', 'up', 'transitioning'
            const [lastPullUpTime, setLastPullUpTime] = useState(0);
            const [currentArmAngle, setCurrentArmAngle] = useState(0);
            const [currentFacingMode, setCurrentFacingMode] = useState('environment'); // Default to back camera
            const [zoomLevel, setZoomLevel] = useState(1.0); // Start at 1.0x zoom (no zoom)
            const [supportsZoom, setSupportsZoom] = useState(false);
            const [zoomCapabilities, setZoomCapabilities] = useState({ min: 1, max: 1 });
            const [isRecording, setIsRecording] = useState(false);
            const [recordedChunks, setRecordedChunks] = useState([]);
            const [recordedVideoUrl, setRecordedVideoUrl] = useState(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const streamRef = useRef(null);
            const poseRef = useRef(null);
            const cameraRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const retryCountRef = useRef(0);
            const maxRetries = 3;

            useEffect(() => {
                // Initialize MediaPipe Pose
                console.log('[Init] Initializing application...');
                console.log('[Init] MediaPipe Pose available:', !!window.Pose);
                console.log('[Init] MediaPipe Camera available:', !!window.Camera);
                
                // Load saved players from localStorage
                loadSavedPlayers();
                
                if (window.Pose) {
                    console.log('[Init] Creating Pose instance...');
                    poseRef.current = new window.Pose({
                        locateFile: (file) => {
                            console.log('[Init] Loading MediaPipe file:', file);
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                        }
                    });
                    
                    poseRef.current.setOptions({
                        modelComplexity: 1,
                        smoothLandmarks: true,
                        enableSegmentation: false,
                        smoothSegmentation: false,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    poseRef.current.onResults(onPoseResults);
                    console.log('[Init] Pose instance configured');
                } else {
                    console.warn('[Init] MediaPipe Pose not available!');
                }

                // Auto-start camera and tracking on page load
                initializeAutoStart();

                return () => {
                    console.log('[Init] Cleaning up...');
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(track => track.stop());
                    }
                    if (cameraRef.current) {
                        cameraRef.current.stop();
                    }
                };
            }, []);

            // Auto-start function with retry logic
            const initializeAutoStart = async () => {
                console.log('[AutoStart] Attempting to initialize camera and tracking...');
                
                try {
                    // Check for camera permission first
                    const permissionStatus = await checkCameraPermission();
                    
                    if (permissionStatus === 'granted') {
                        console.log('[AutoStart] Camera permission already granted');
                        setHasPermission(true);
                        
                        // Auto-start tracking if players exist
                        setTimeout(() => {
                            if (players.length > 0) {
                                console.log('[AutoStart] Players exist, starting tracking automatically');
                                autoStartTracking();
                            } else {
                                console.log('[AutoStart] No players yet, showing camera setup');
                                startCameraWithRetry();
                            }
                        }, 500);
                    } else if (permissionStatus === 'prompt') {
                        console.log('[AutoStart] Camera permission needs to be requested');
                        // Automatically request permission
                        setTimeout(() => {
                            requestCameraPermissionWithRetry();
                        }, 1000);
                    } else {
                        console.log('[AutoStart] Camera permission denied');
                        setCameraError('Camera access is required for tracking. Please grant permission and refresh the page.');
                    }
                } catch (err) {
                    console.error('[AutoStart] Error checking camera permission:', err);
                    // Try to request permission anyway
                    setTimeout(() => {
                        requestCameraPermissionWithRetry();
                    }, 1000);
                }
            };

            // Check camera permission status
            const checkCameraPermission = async () => {
                try {
                    if (navigator.permissions && navigator.permissions.query) {
                        const result = await navigator.permissions.query({ name: 'camera' });
                        console.log('[Permission] Camera permission status:', result.state);
                        return result.state;
                    }
                } catch (err) {
                    console.log('[Permission] Could not query camera permission:', err);
                }
                return 'prompt';
            };

            // Request camera permission with retry logic
            const requestCameraPermissionWithRetry = async () => {
                retryCountRef.current = 0;
                let success = false;
                
                while (retryCountRef.current < maxRetries && !success) {
                    try {
                        console.log(`[AutoStart] Requesting camera permission (attempt ${retryCountRef.current + 1}/${maxRetries})...`);
                        setCameraError('');
                        
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: 'environment' } 
                        });
                        
                        console.log('[AutoStart] Camera permission granted');
                        setHasPermission(true);
                        success = true;
                        
                        // Stop the stream for now
                        stream.getTracks().forEach(track => track.stop());
                        
                        // Start the camera and tracking
                        setTimeout(() => {
                            if (players.length > 0) {
                                autoStartTracking();
                            } else {
                                startCameraWithRetry();
                            }
                        }, 500);
                        
                    } catch (err) {
                        console.error(`[AutoStart] Permission request failed (attempt ${retryCountRef.current + 1}/${maxRetries}):`, err);
                        retryCountRef.current++;
                        
                        if (retryCountRef.current >= maxRetries) {
                            setHasPermission(false);
                            if (err.name === 'NotAllowedError') {
                                setCameraError('Camera access was denied. Please grant permission to use auto-tracking or use manual controls.');
                            } else if (err.name === 'NotFoundError') {
                                setCameraError('No camera found on this device. Manual controls only.');
                            } else if (err.name === 'NotReadableError') {
                                setCameraError('Camera is in use by another application. Close other apps and refresh.');
                            } else {
                                setCameraError('Camera error: ' + err.message + '. Manual controls available.');
                            }
                        } else {
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                }
            };

            // Auto-start tracking (only if permission granted)
            const autoStartTracking = () => {
                console.log('[AutoStart] Starting tracking automatically...');
                setIsTracking(true);
                setIsDetecting(true);
                setDetectionStatus('ðŸš€ Auto-starting camera and detection...');
                setTimeout(() => setDetectionStatus(''), 3000);
                startCameraWithRetry();
            };

            // Start camera with retry logic
            const startCameraWithRetry = async (facingMode = 'environment', retryAttempt = 0) => {
                try {
                    console.log(`[Camera] Starting camera with retry (attempt ${retryAttempt + 1}/${maxRetries})...`);
                    await startCamera(facingMode);
                } catch (err) {
                    console.error(`[Camera] Start failed (attempt ${retryAttempt + 1}/${maxRetries}):`, err);
                    
                    if (retryAttempt < maxRetries - 1) {
                        // Wait and retry
                        const delay = 2000 * (retryAttempt + 1); // Increasing delay
                        console.log(`[Camera] Retrying in ${delay}ms...`);
                        setDetectionStatus(`âš ï¸ Camera initialization failed. Retrying in ${delay/1000}s...`);
                        
                        setTimeout(() => {
                            startCameraWithRetry(facingMode, retryAttempt + 1);
                        }, delay);
                    } else {
                        console.error('[Camera] All retry attempts exhausted');
                        setCameraError('Unable to start camera after multiple attempts. Please use manual controls or refresh the page.');
                        setDetectionStatus('âŒ Auto-tracking unavailable - Use manual +/- buttons');
                        setTimeout(() => setDetectionStatus(''), 3000);
                        setShowCamera(false);
                        setIsDetecting(false);
                    }
                }
            };

            // Load saved players from localStorage
            const loadSavedPlayers = () => {
                try {
                    const savedPlayers = localStorage.getItem('pullUpGamePlayers');
                    if (savedPlayers) {
                        const parsedPlayers = JSON.parse(savedPlayers);
                        // Reset scores but keep names
                        const playersWithResetScores = parsedPlayers.map(p => ({
                            ...p,
                            score: 0,
                            sets: []
                        }));
                        setPlayers(playersWithResetScores);
                        console.log('[Storage] Loaded saved players:', playersWithResetScores.map(p => p.name));
                    }
                } catch (err) {
                    console.error('[Storage] Error loading players:', err);
                }
            };

            // Save players to localStorage (only names, not scores)
            const savePlayers = (playersList) => {
                try {
                    // Only save names, not scores
                    const playersToSave = playersList.map(p => ({
                        name: p.name,
                        score: 0,
                        sets: []
                    }));
                    localStorage.setItem('pullUpGamePlayers', JSON.stringify(playersToSave));
                    console.log('[Storage] Saved players to localStorage');
                } catch (err) {
                    console.error('[Storage] Error saving players:', err);
                }
            };

            // Clear saved players from localStorage
            const clearSavedPlayers = () => {
                try {
                    localStorage.removeItem('pullUpGamePlayers');
                    console.log('[Storage] Cleared saved players from localStorage');
                } catch (err) {
                    console.error('[Storage] Error clearing players:', err);
                }
            };

            const requestCameraPermission = async () => {
                try {
                    setCameraError('');
                    console.log('[Camera] Requesting camera permission...');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    
                    console.log('[Camera] Camera permission granted', stream);
                    console.log('[Camera] Video tracks:', stream.getVideoTracks());
                    setHasPermission(true);
                    
                    // Stop the stream for now, we'll start it again when user clicks start
                    stream.getTracks().forEach(track => {
                        console.log('[Camera] Stopping temp track:', track.label);
                        track.stop();
                    });
                    
                    // Auto-start camera after permission is granted
                    setTimeout(() => {
                        startCameraWithRetry();
                    }, 500);
                    
                } catch (err) {
                    console.error('[Camera] Permission error:', err);
                    setHasPermission(false);
                    
                    if (err.name === 'NotAllowedError') {
                        setCameraError('Camera access was denied. Please click the button below to grant permission.');
                    } else if (err.name === 'NotFoundError') {
                        setCameraError('No camera found on this device.');
                    } else if (err.name === 'NotReadableError') {
                        setCameraError('Camera is already in use by another application.');
                    } else {
                        setCameraError('Unable to access camera: ' + err.message);
                    }
                }
            };

            const onPoseResults = (results) => {
                if (!canvasRef.current || !videoRef.current || !showCamera || !isDetecting) {
                    return;
                }
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const video = videoRef.current;
                
                // Draw video frame first
                if (video.readyState >= 2) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }
                
                // Add pose landmarks if available
                if (results.poseLandmarks) {
                    try {
                        drawPoseLandmarks(ctx, results.poseLandmarks);
                        detectPullUp(results.poseLandmarks);
                        
                        // Draw pullup counter on canvas
                        if (players.length > 0 && players[currentPlayerIndex]) {
                            ctx.save();
                            ctx.font = 'bold 48px Arial';
                            ctx.fillStyle = '#ffffff';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 4;
                            ctx.textAlign = 'right';
                            const counterText = `Pull-ups: ${players[currentPlayerIndex].score}`;
                            const textX = canvas.width - 20;
                            const textY = 60;
                            ctx.strokeText(counterText, textX, textY);
                            ctx.fillText(counterText, textX, textY);
                            
                            // Draw arm angle below counter
                            ctx.font = 'bold 32px Arial';
                            ctx.fillStyle = currentArmAngle > 148 ? '#00ff00' : '#ff9800';
                            const angleY = textY + 45;
                            const angleText = `Angle: ${Math.round(currentArmAngle)}Â°`;
                            ctx.strokeText(angleText, textX, angleY);
                            ctx.fillText(angleText, textX, angleY);
                            
                            ctx.restore();
                        }
                    } catch (err) {
                        console.error('[Pose] Detection error:', err);
                    }
                }
            };

            const drawPoseLandmarks = (ctx, landmarks) => {
                const canvas = canvasRef.current;
                
                // Calculate bounding box for the person
                let minX = canvas.width, minY = canvas.height;
                let maxX = 0, maxY = 0;
                
                landmarks.forEach(landmark => {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                });
                
                // Add padding to the bounding box
                const padding = 20;
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(canvas.width, maxX + padding);
                maxY = Math.min(canvas.height, maxY + padding);
                
                // Draw bounding box with glow effect
                const boxWidth = maxX - minX;
                const boxHeight = maxY - minY;
                
                // Outer glow
                ctx.shadowColor = pullUpState === 'up' ? '#00ff00' : '#00aaff';
                ctx.shadowBlur = 20;
                ctx.strokeStyle = pullUpState === 'up' ? '#00ff00' : '#00aaff';
                ctx.lineWidth = 4;
                ctx.strokeRect(minX, minY, boxWidth, boxHeight);
                
                // Inner line
                ctx.shadowBlur = 0;
                ctx.lineWidth = 2;
                ctx.strokeRect(minX, minY, boxWidth, boxHeight);
                
                // Draw label at top of box
                const label = pullUpState === 'up' ? 'â†‘ UP' : 'â†“ DOWN';
                ctx.fillStyle = pullUpState === 'up' ? '#00ff00' : '#00aaff';
                ctx.font = 'bold 24px Arial';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(label, minX + 10, minY - 10);
                ctx.shadowBlur = 0;
                
                // Draw key points for pull-up detection
                const keyPoints = [0, 11, 12, 13, 14, 15, 16]; // Head/nose, Shoulders, elbows, wrists
                
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                
                keyPoints.forEach(index => {
                    if (landmarks[index]) {
                        const x = landmarks[index].x * canvas.width;
                        const y = landmarks[index].y * canvas.height;
                        
                        // Special color for head/nose
                        if (index === 0) {
                            ctx.fillStyle = '#ff00ff'; // Magenta for head
                        } else {
                            ctx.fillStyle = '#00ff00'; // Green for other points
                        }
                        
                        // Larger circles for better visibility
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // White center
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
                
                // Draw connections between key points
                const connections = [
                    [11, 13], [13, 15], // Left arm
                    [12, 14], [14, 16], // Right arm
                    [11, 12], // Shoulders
                    [0, 11], [0, 12]  // Head to shoulders
                ];
                
                ctx.lineWidth = 3;
                connections.forEach(([start, end]) => {
                    if (landmarks[start] && landmarks[end]) {
                        const startX = landmarks[start].x * canvas.width;
                        const startY = landmarks[start].y * canvas.height;
                        const endX = landmarks[end].x * canvas.width;
                        const endY = landmarks[end].y * canvas.height;
                        
                        // Special color for head connections
                        if (start === 0 || end === 0) {
                            ctx.strokeStyle = '#ff00ff'; // Magenta for head connections
                        } else {
                            ctx.strokeStyle = '#00ff00'; // Green for arm connections
                        }
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                });
            };

            const detectPullUp = (landmarks) => {
                // Check for required landmarks: nose/head (0), shoulders (11, 12), elbows (13, 14), wrists (15, 16)
                if (!landmarks[0] || !landmarks[11] || !landmarks[12] || !landmarks[13] || !landmarks[14] || !landmarks[15] || !landmarks[16]) {
                    console.log('[Detection] Missing key landmarks');
                    return;
                }
                
                // Get key landmarks
                const nose = landmarks[0];  // Head position (nose is a good proxy for head)
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                const leftElbow = landmarks[13];
                const rightElbow = landmarks[14];
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];
                
                // Calculate average positions
                const headY = nose.y;
                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
                const wristY = (leftWrist.y + rightWrist.y) / 2;
                
                // Calculate arm angles for better detection
                const calculateAngle = (shoulder, elbow, wrist) => {
                    const rad1 = Math.atan2(elbow.y - shoulder.y, elbow.x - shoulder.x);
                    const rad2 = Math.atan2(wrist.y - elbow.y, wrist.x - elbow.x);
                    let angle = Math.abs(rad1 - rad2) * (180 / Math.PI);
                    if (angle > 180) angle = 360 - angle;
                    return angle;
                };
                
                const leftArmAngle = calculateAngle(leftShoulder, leftElbow, leftWrist);
                const rightArmAngle = calculateAngle(rightShoulder, rightElbow, rightWrist);
                const avgArmAngle = (leftArmAngle + rightArmAngle) / 2;
                
                // Update current arm angle state
                setCurrentArmAngle(avgArmAngle);
                
                // NEW DETECTION LOGIC (UPDATED to match camera-test.html):
                // 1. UP: Head is above wrists (head pulled up above the bar where hands are)
                // 2. DOWN: Extended arms only (hanging position)
                
                const headAboveWrists = headY < wristY - 0.05;  // Head is higher than wrists (lower Y value)
                const wristsBelowShoulders = wristY > shoulderY + 0.05;  // Wrists are lower than shoulders (higher Y value)
                const armsExtended = avgArmAngle < 35; // Arms extended: angle below 35 degrees (slightly looser)
                
                console.log('[Detection] Head Y:', headY.toFixed(3), 
                           'Wrist Y:', wristY.toFixed(3), 
                           'Avg Angle:', avgArmAngle.toFixed(1),
                           'State:', pullUpState);
                
                // Determine position based on new criteria
                const isUp = headAboveWrists;  // Head above wrists = UP position
                const isDown = armsExtended;  // Extended arms = DOWN position (simplified)
                
                console.log('[Detection] isUp:', isUp, 'isDown:', isDown, 
                           'headAbove:', headAboveWrists, 'extended:', armsExtended);
                
                const currentTime = Date.now();
                
                // State machine for pull-up detection
                if (pullUpState === 'down' && isUp) {
                    setPullUpState('up');
                    console.log('[Detection] âœ“ Transitioned to UP position');
                    setDetectionStatus('Up position detected! ðŸ’ª');
                    setTimeout(() => setDetectionStatus(''), 3000);
                } else if (pullUpState === 'up' && isDown) {
                    setPullUpState('down');
                    console.log('[Detection] âœ“ Transitioned to DOWN position');
                    
                    // Only count if enough time has passed since last pull-up (prevent double counting)
                    if (currentTime - lastPullUpTime > 1000) { // 1 second cooldown
                        incrementScore(currentPlayerIndex);
                        setLastPullUpTime(currentTime);
                        console.log('[Detection] âœ“âœ“ PULL-UP COMPLETED! +1 point');
                        setDetectionStatus('âœ… Pull-up completed! +1 point');
                        
                        // Play success feedback
                        const ctx = canvasRef.current?.getContext('2d');
                        if (ctx) {
                            // Flash green border
                            setTimeout(() => {
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 10;
                                ctx.strokeRect(5, 5, canvasRef.current.width - 10, canvasRef.current.height - 10);
                            }, 0);
                        }
                        
                        // Clear status after 3 seconds
                        setTimeout(() => setDetectionStatus(''), 3000);
                    } else {
                        console.log('[Detection] Cooldown active, not counting');
                    }
                }
            };

            const startCamera = async (facingMode = 'environment') => {
                try {
                    setCameraError('');
                    console.log(`[Camera] Starting camera with facingMode: ${facingMode}...`);
                    
                    // IMPORTANT: Show camera UI FIRST before doing anything else
                    setShowCamera(true);
                    
                    // Stop existing stream if any
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(track => track.stop());
                        streamRef.current = null;
                    }
                    if (cameraRef.current) {
                        cameraRef.current.stop();
                        cameraRef.current = null;
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: { ideal: facingMode },
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } 
                    });
                    
                    console.log(`[Camera] Stream obtained: ${stream.id}, facingMode: ${facingMode}`);
                    setCurrentFacingMode(facingMode);
                    const tracks = stream.getVideoTracks();
                    console.log('[Camera] Video tracks:', tracks.length);
                    tracks.forEach(track => {
                        const settings = track.getSettings();
                        const facing = settings.facingMode || 'unknown';
                        console.log(`[Camera] Track: ${track.label}, facing: ${facing}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
                        
                        // Check for zoom capabilities
                        const capabilities = track.getCapabilities();
                        if (capabilities.zoom) {
                            console.log('[Camera] Zoom supported! Min:', capabilities.zoom.min, 'Max:', capabilities.zoom.max, 'Step:', capabilities.zoom.step);
                            setSupportsZoom(true);
                            setZoomCapabilities({ min: capabilities.zoom.min, max: capabilities.zoom.max });
                            setZoomLevel(capabilities.zoom.min); // Start at minimum zoom
                        } else {
                            console.log('[Camera] Native zoom not supported, using CSS transform');
                            setSupportsZoom(false);
                            setZoomLevel(1.0); // Start at 1.0 for CSS zoom
                        }
                    });
                    
                    if (videoRef.current && canvasRef.current) {
                        streamRef.current = stream;
                        videoRef.current.srcObject = stream;
                        console.log('[Camera] Video srcObject set');
                        
                        // Set up metadata handler
                        videoRef.current.addEventListener('loadedmetadata', () => {
                            const videoWidth = videoRef.current.videoWidth || 640;
                            const videoHeight = videoRef.current.videoHeight || 480;
                            
                            console.log(`[Camera] Video metadata loaded: ${videoWidth}x${videoHeight}`);
                            canvasRef.current.width = videoWidth;
                            canvasRef.current.height = videoHeight;
                            console.log(`[Camera] Canvas size set: ${canvasRef.current.width}x${canvasRef.current.height}`);
                        });
                        
                        // Play video
                        await videoRef.current.play();
                        console.log(`[Camera] Video playing, readyState: ${videoRef.current.readyState}`);
                        
                        // Start drawing loop - exactly like camera-test.html
                        let frameCount = 0;
                        let isDrawing = true;
                        
                        const drawLoop = () => {
                            if (!isDrawing || !streamRef.current) {
                                console.log('[Canvas] Drawing loop stopped');
                                return;
                            }
                            
                            const canvas = canvasRef.current;
                            const ctx = canvas.getContext('2d');
                            const video = videoRef.current;
                            
                            if (video && video.readyState >= 2) {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                
                                // Draw frame counter for debugging
                                ctx.fillStyle = 'lime';
                                ctx.font = '20px Arial';
                                ctx.fillText(`Frame: ${frameCount}`, 10, 30);
                                
                                // if (frameCount % 60 === 0) {
                                //     console.log(`[Canvas] Drawing frame ${frameCount}`);
                                // }
                                frameCount++;
                            } else if (frameCount === 0) {
                                console.log(`[Canvas] Video not ready, readyState: ${video ? video.readyState : 'no video'}`);
                            }
                            
                            requestAnimationFrame(drawLoop);
                        };
                        
                        // Store the stop function
                        if (!window.cameraLoops) window.cameraLoops = [];
                        window.cameraLoops.push(() => { isDrawing = false; });
                        
                        console.log('[Camera] Starting draw loop...');
                        drawLoop();
                        
                        // Initialize pose detection after drawing starts - use direct requestAnimationFrame approach
                        setTimeout(() => {
                            if (poseRef.current) {
                                try {
                                    console.log('[MediaPipe] Initializing pose detection with direct frame processing...');
                                    
                                    // Use direct requestAnimationFrame approach instead of Camera utility
                                    let poseFrameCount = 0;
                                    let isPoseProcessing = false;
                                    
                                    const processPoseFrame = async () => {
                                        if (!streamRef.current || !videoRef.current || !poseRef.current) {
                                            console.log('[MediaPipe] Stopping pose processing - stream ended');
                                            return;
                                        }
                                        
                                        if (isDetecting && videoRef.current.readyState >= 2 && !isPoseProcessing) {
                                            isPoseProcessing = true;
                                            try {
                                                await poseRef.current.send({image: videoRef.current});
                                                poseFrameCount++;
                                                
                                                if (poseFrameCount % 30 === 0) {
                                                    console.log(`[MediaPipe] Processed ${poseFrameCount} pose frames`);
                                                }
                                            } catch (err) {
                                                console.warn('[MediaPipe] Frame processing error:', err);
                                            }
                                            isPoseProcessing = false;
                                        }
                                        
                                        // Continue processing at ~30fps
                                        setTimeout(() => {
                                            requestAnimationFrame(processPoseFrame);
                                        }, 33);
                                    };
                                    
                                    // Start pose processing
                                    processPoseFrame();
                                    console.log('[MediaPipe] Pose detection initialized successfully (direct mode)');
                                    setDetectionStatus('âœ… Auto-detection ready! Stand in frame to start counting');
                                    
                                    // Store reference for cleanup
                                    cameraRef.current = { 
                                        stop: () => {
                                            console.log('[MediaPipe] Stopping pose processing');
                                            streamRef.current = null; // This will stop the processPoseFrame loop
                                        }
                                    };
                                    
                                    // Clear the success message after 3 seconds
                                    setTimeout(() => {
                                        if (isDetecting) {
                                            setDetectionStatus('');
                                        }
                                    }, 3000);
                                } catch (poseErr) {
                                    console.error('[MediaPipe] Pose detection failed:', poseErr);
                                    console.log('[MediaPipe] Continuing with manual counting mode');
                                    cameraRef.current = null;
                                    setDetectionStatus('âš ï¸ Auto-detection unavailable - Please use manual +/- buttons to count');
                                    setTimeout(() => setDetectionStatus(''), 3000);
                                }
                            } else {
                                console.warn('[MediaPipe] Pose not available - using manual counting only');
                                setDetectionStatus('âš ï¸ Auto-detection unavailable - Please use manual +/- buttons to count');
                                setTimeout(() => setDetectionStatus(''), 3000);
                            }
                        }, 1000);
                    }
                } catch (err) {
                    console.error('[Camera] Start error:', err.name, err.message);
                    setCameraError(`Failed to start camera: ${err.message}`);
                    setShowCamera(false);
                }
            };

            const switchCamera = () => {
                // Toggle between front and back camera
                const newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
                console.log(`[Camera] Switching camera from ${currentFacingMode} to ${newFacingMode}...`);
                startCameraWithRetry(newFacingMode);
            };

            // Apply zoom to the video track
            const applyZoomToTrack = async (zoomValue) => {
                if (!streamRef.current) return;
                
                const videoTrack = streamRef.current.getVideoTracks()[0];
                if (!videoTrack) return;
                
                try {
                    const capabilities = videoTrack.getCapabilities();
                    
                    if (capabilities.zoom) {
                        console.log('[Zoom] Applying native camera zoom:', zoomValue);
                        await videoTrack.applyConstraints({
                            advanced: [{ zoom: zoomValue }]
                        });
                    } else {
                        console.log('[Zoom] Native zoom not supported, using CSS transform');
                    }
                } catch (err) {
                    console.warn('[Zoom] Error applying zoom:', err);
                }
            };

            const zoomIn = async () => {
                setZoomLevel(prev => {
                    const newZoom = supportsZoom 
                        ? Math.min(prev + 0.5, zoomCapabilities.max)
                        : Math.min(prev + 0.1, 3.0); // CSS zoom can go higher
                    
                    if (supportsZoom) {
                        applyZoomToTrack(newZoom);
                    }
                    
                    console.log('[Zoom] Zoom in to:', newZoom);
                    return newZoom;
                });
            };

            const zoomOut = async () => {
                setZoomLevel(prev => {
                    const newZoom = supportsZoom
                        ? Math.max(prev - 0.5, zoomCapabilities.min)
                        : Math.max(prev - 0.1, 0.5); // Min CSS zoom
                    
                    if (supportsZoom) {
                        applyZoomToTrack(newZoom);
                    }
                    
                    console.log('[Zoom] Zoom out to:', newZoom);
                    return newZoom;
                });
            };

            const resetZoom = async () => {
                const defaultZoom = supportsZoom ? zoomCapabilities.min : 1.0;
                setZoomLevel(defaultZoom);
                
                if (supportsZoom) {
                    applyZoomToTrack(defaultZoom);
                }
                
                console.log('[Zoom] Reset zoom to:', defaultZoom);
            };

            const startRecording = () => {
                if (!canvasRef.current) {
                    console.error('[Recording] Canvas not available');
                    return;
                }

                try {
                    console.log('[Recording] Starting video recording...');
                    
                    // Capture the canvas stream which includes the video + pose overlay
                    const canvasStream = canvasRef.current.captureStream(30); // 30 fps
                    
                    // Set up MediaRecorder
                    const options = { mimeType: 'video/webm;codecs=vp9' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm;codecs=vp8';
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options.mimeType = 'video/webm';
                        }
                    }
                    
                    const mediaRecorder = new MediaRecorder(canvasStream, options);
                    mediaRecorderRef.current = mediaRecorder;
                    
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                            console.log('[Recording] Chunk recorded:', event.data.size, 'bytes');
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        console.log('[Recording] Recording stopped, total chunks:', chunks.length);
                        setRecordedChunks(chunks);
                        
                        // Create a blob and URL for the recorded video
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        setRecordedVideoUrl(url);
                        console.log('[Recording] Video URL created:', url);
                    };
                    
                    mediaRecorder.start();
                    setIsRecording(true);
                    console.log('[Recording] MediaRecorder started');
                    setDetectionStatus('ðŸ”´ Recording started!');
                    setTimeout(() => setDetectionStatus(''), 3000);
                } catch (err) {
                    console.error('[Recording] Error starting recording:', err);
                    setDetectionStatus('âŒ Recording failed: ' + err.message);
                    setTimeout(() => setDetectionStatus(''), 5000);
                }
            };

            const stopRecording = () => {
                if (mediaRecorderRef.current && isRecording) {
                    console.log('[Recording] Stopping recording...');
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                    setDetectionStatus('âœ… Recording saved! Click download to save.');
                    setTimeout(() => setDetectionStatus(''), 5000);
                }
            };

            const downloadRecording = () => {
                if (recordedVideoUrl) {
                    const currentPlayer = players[currentPlayerIndex];
                    const playerName = currentPlayer ? currentPlayer.name.replace(/\s+/g, '_') : 'player';
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const filename = `pullup_${playerName}_${timestamp}.webm`;
                    
                    const a = document.createElement('a');
                    a.href = recordedVideoUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    console.log('[Recording] Video downloaded:', filename);
                    setDetectionStatus('âœ… Video downloaded: ' + filename);
                    setTimeout(() => setDetectionStatus(''), 5000);
                }
            };

            const stopCamera = () => {
                console.log('[Camera] Stopping camera...');
                
                // Stop recording if active
                if (isRecording && mediaRecorderRef.current) {
                    console.log('[Camera] Stopping active recording...');
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                }
                
                // Stop drawing loops
                if (window.cameraLoops) {
                    window.cameraLoops.forEach(stopFn => stopFn());
                    window.cameraLoops = [];
                    console.log('[Camera] Drawing loops stopped');
                }
                
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => {
                        console.log('[Camera] Stopping track:', track.label);
                        track.stop();
                    });
                    streamRef.current = null;
                }
                if (cameraRef.current) {
                    try {
                        console.log('[Camera] Stopping MediaPipe camera');
                        if (typeof cameraRef.current.stop === 'function') {
                            cameraRef.current.stop();
                        }
                    } catch (err) {
                        console.warn('[Camera] Error stopping MediaPipe camera:', err);
                    }
                    cameraRef.current = null;
                }
                
                console.log('[Camera] Camera stopped');
                setShowCamera(false);
                setIsDetecting(false);
                setDetectionStatus('');
            };

            const addPlayer = () => {
                if (newPlayerName.trim()) {
                    const newPlayer = { name: newPlayerName.trim(), score: 0, sets: [] };
                    console.log('[Players] Adding player:', newPlayer.name);
                    const updatedPlayers = [...players, newPlayer];
                    setPlayers(updatedPlayers);
                    savePlayers(updatedPlayers);
                    setNewPlayerName('');
                }
            };

            const removePlayer = (index) => {
                console.log('[Players] Removing player:', players[index]?.name);
                const updatedPlayers = players.filter((_, i) => i !== index);
                setPlayers(updatedPlayers);
                savePlayers(updatedPlayers);
                if (currentPlayerIndex >= players.length - 1) {
                    setCurrentPlayerIndex(Math.max(0, players.length - 2));
                }
            };

            const incrementScore = (index) => {
                const updated = [...players];
                updated[index].score += 1;
                console.log('[Score] Incrementing score for', updated[index].name, 'to', updated[index].score);
                setPlayers(updated);
            };

            const decrementScore = (index) => {
                const updated = [...players];
                updated[index].score = Math.max(0, updated[index].score - 1);
                console.log('[Score] Decrementing score for', updated[index].name, 'to', updated[index].score);
                setPlayers(updated);
            };

            const startTracking = () => {
                if (players.length === 0) {
                    alert('Add players first!');
                    return;
                }
                
                console.log('[Tracking] Starting tracking mode');
                console.log('[Tracking] Current player:', players[currentPlayerIndex]?.name);
                console.log('[Tracking] Has permission:', hasPermission);
                
                setIsTracking(true);
                setIsDetecting(true);
                setDetectionStatus('ðŸš€ Initializing camera and detection...');
                setTimeout(() => setDetectionStatus(''), 3000);
                
                if (!hasPermission) {
                    console.log('[Tracking] Requesting camera permission first...');
                    requestCameraPermissionWithRetry();
                } else {
                    console.log('[Tracking] Permission already granted, starting camera');
                    startCameraWithRetry('environment'); // Start with back camera and retry logic
                }
            };

            const stopTracking = () => {
                console.log('[Tracking] Stopping tracking mode');
                setIsTracking(false);
                setIsDetecting(false);
                stopCamera();
            };

            const toggleDetection = () => {
                console.log('[Detection] Toggling detection from', isDetecting, 'to', !isDetecting);
                setIsDetecting(!isDetecting);
                if (!isDetecting) {
                    // Enabling detection
                    if (poseRef.current && cameraRef.current) {
                        setDetectionStatus('âœ… Auto-detection enabled - Ready to count!');
                        console.log('[Detection] Auto-detection enabled with MediaPipe');
                        setTimeout(() => setDetectionStatus(''), 3000);
                    } else {
                        setDetectionStatus('âš ï¸ Auto-detection unavailable - Please use manual +/- buttons');
                        console.log('[Detection] MediaPipe not available, using manual mode');
                        setTimeout(() => setDetectionStatus(''), 3000);
                    }
                } else {
                    // Pausing detection
                    setDetectionStatus('â¸ï¸ Auto-detection paused - Use manual buttons');
                    console.log('[Detection] Auto-detection paused');
                    setTimeout(() => setDetectionStatus(''), 3000);
                }
            };

            const nextPlayer = () => {
                const newIndex = (currentPlayerIndex + 1) % players.length;
                console.log('[Players] Switching to next player:', players[newIndex]?.name, 'index:', newIndex);
                setCurrentPlayerIndex(newIndex);
            };

            const previousPlayer = () => {
                const newIndex = (currentPlayerIndex - 1 + players.length) % players.length;
                console.log('[Players] Switching to previous player:', players[newIndex]?.name, 'index:', newIndex);
                setCurrentPlayerIndex(newIndex);
            };

            const resetScores = () => {
                console.log('[Players] Resetting all scores');
                setPlayers(players.map(p => ({ ...p, score: 0, sets: [] })));
            };

            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-pink-900">
                    <div className="w-full max-w-7xl mx-auto">
                        <div className="text-center px-4 py-6">
                            <h1 className="text-3xl sm:text-4xl lg:text-5xl font-bold text-white mb-2 flex items-center justify-center gap-2 sm:gap-3">
                                <Trophy className="text-yellow-400" size={32} />
                                <span className="inline sm:inline">Pull-Ups Challenge</span>
                            </h1>
                            <p className="text-sm sm:text-base text-blue-200">Track your team's performance!</p>
                        </div>

                        <div className="flex flex-col lg:grid lg:grid-cols-2 gap-4 lg:gap-6 px-0 sm:px-4">
                            {/* Top Panel (Mobile) / Left Panel (Desktop) - Camera and Current Player */}
                            <div className="space-y-4 order-1">
                                <div className="bg-white/10 backdrop-blur-lg rounded-none lg:rounded-2xl p-4 sm:p-6 border-0 lg:border border-white/20">
                                    <h2 className="text-xl sm:text-2xl font-bold text-white mb-4 flex items-center gap-2">
                                        <Camera size={20} className="sm:w-6 sm:h-6" />
                                        Live Tracking
                                    </h2>
                                    
                                    <div className="bg-black/30 rounded-xl overflow-hidden mb-4 flex items-center justify-center relative w-full" style={{aspectRatio: '4/3', minHeight: '300px'}}>
                                        {showCamera ? (
                                            <div className="relative w-full h-full">
                                                <video 
                                                    ref={videoRef} 
                                                    autoPlay 
                                                    playsInline
                                                    muted
                                                    className="absolute top-0 left-0 w-full h-full object-cover"
                                                    style={{
                                                        opacity: 0.01, 
                                                        pointerEvents: 'none', 
                                                        transform: supportsZoom ? 'scale(1)' : `scale(${zoomLevel})`
                                                    }}
                                                />
                                                <canvas 
                                                    ref={canvasRef}
                                                    className="absolute top-0 left-0 w-full h-full object-cover"
                                                    style={{
                                                        transform: supportsZoom ? 'scale(1)' : `scale(${zoomLevel})`
                                                    }}
                                                />
                                                {detectionStatus && (
                                                    <div className={`absolute top-4 left-4 right-4 px-4 py-3 rounded-lg text-sm font-bold z-10 ${
                                                        detectionStatus.includes('âš ï¸') 
                                                            ? 'bg-orange-500/90 text-white' 
                                                            : detectionStatus.includes('âœ…') 
                                                            ? 'bg-green-500/90 text-white'
                                                            : 'bg-black/70 text-white'
                                                    }`}>
                                                        {detectionStatus}
                                                    </div>
                                                )}
                                                <div className="absolute top-2 sm:top-4 right-2 sm:right-4 flex gap-1 sm:gap-2 z-10">
                                                    {isRecording && (
                                                        <div className="flex items-center gap-1 bg-red-500 px-2 py-1 rounded-full mr-2">
                                                            <div className="w-2 h-2 bg-white rounded-full animate-pulse"></div>
                                                            <span className="text-white text-xs font-bold">REC</span>
                                                        </div>
                                                    )}
                                                    <div className={`w-2 h-2 sm:w-3 sm:h-3 rounded-full ${isDetecting ? 'bg-green-400' : 'bg-red-400'}`} />
                                                    <span className="text-white text-xs sm:text-sm">
                                                        {isDetecting ? 'Detecting' : 'Paused'}
                                                    </span>
                                                </div>
                                                <div className="absolute bottom-2 sm:bottom-4 right-2 sm:right-4 flex flex-col gap-1 sm:gap-2 z-10">
                                                    <button
                                                        onClick={zoomIn}
                                                        disabled={supportsZoom && zoomLevel >= zoomCapabilities.max}
                                                        className="bg-black/70 hover:bg-black/80 disabled:opacity-50 disabled:cursor-not-allowed text-white w-10 h-10 sm:w-12 sm:h-12 rounded-full flex items-center justify-center transition font-bold text-lg sm:text-xl shadow-lg"
                                                        title="Zoom In"
                                                    >
                                                        +
                                                    </button>
                                                    <div className="bg-black/70 text-white text-xs text-center py-1 px-2 rounded shadow-lg">
                                                        <div className="font-bold">
                                                            {supportsZoom ? `${zoomLevel.toFixed(1)}x` : `${(zoomLevel * 100).toFixed(0)}%`}
                                                        </div>
                                                        <div className="text-[10px] opacity-75">
                                                            {supportsZoom ? 'Native' : 'CSS'}
                                                        </div>
                                                    </div>
                                                    <button
                                                        onClick={zoomOut}
                                                        disabled={supportsZoom && zoomLevel <= zoomCapabilities.min}
                                                        className="bg-black/70 hover:bg-black/80 disabled:opacity-50 disabled:cursor-not-allowed text-white w-10 h-10 sm:w-12 sm:h-12 rounded-full flex items-center justify-center transition font-bold text-lg sm:text-xl shadow-lg"
                                                        title="Zoom Out"
                                                    >
                                                        âˆ’
                                                    </button>
                                                    <button
                                                        onClick={resetZoom}
                                                        className="bg-blue-500/70 hover:bg-blue-600/80 text-white w-10 h-10 sm:w-12 sm:h-12 rounded-full flex items-center justify-center transition text-xs sm:text-sm shadow-lg"
                                                        title="Reset Zoom"
                                                    >
                                                        1:1
                                                    </button>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="text-white/50 text-center p-4 sm:p-8">
                                                <Camera size={48} className="sm:w-16 sm:h-16 mx-auto mb-4" />
                                                {cameraError ? (
                                                    <div>
                                                        <p className="text-red-400 mb-2 text-sm sm:text-base">{cameraError}</p>
                                                        <button
                                                            onClick={requestCameraPermission}
                                                            className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg mt-2 transition text-sm sm:text-base"
                                                        >
                                                            Grant Camera Permission
                                                        </button>
                                                    </div>
                                                ) : hasPermission ? (
                                                    <p className="text-sm sm:text-base">Camera ready. Click "Start Tracking" to begin.</p>
                                                ) : (
                                                    <div>
                                                        <p className="mb-4 text-sm sm:text-base">Camera access required to track pull-ups</p>
                                                        <button
                                                            onClick={requestCameraPermission}
                                                            className="bg-blue-500 hover:bg-blue-600 text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg transition font-bold text-sm sm:text-base"
                                                        >
                                                            Enable Camera
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>

                                    {players.length > 0 && (
                                        <div className="space-y-3 sm:space-y-4">
                                            <div className="bg-gradient-to-r from-blue-500 to-purple-500 rounded-xl p-4 sm:p-6 text-white">
                                                <p className="text-xs sm:text-sm opacity-80 mb-1">Now Performing</p>
                                                <h3 className="text-2xl sm:text-3xl font-bold mb-3 sm:mb-4">{players[currentPlayerIndex]?.name}</h3>
                                                <div className="flex items-center justify-between">
                                                    <div>
                                                        <p className="text-xs sm:text-sm opacity-80">Current Score</p>
                                                        <p className="text-3xl sm:text-4xl font-bold">{players[currentPlayerIndex]?.score}</p>
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button
                                                            onClick={() => decrementScore(currentPlayerIndex)}
                                                            className="bg-white/20 hover:bg-white/30 p-2 sm:p-3 rounded-lg transition"
                                                        >
                                                            <Minus size={20} className="sm:w-6 sm:h-6" />
                                                        </button>
                                                        <button
                                                            onClick={() => incrementScore(currentPlayerIndex)}
                                                            className="bg-white/20 hover:bg-white/30 p-2 sm:p-3 rounded-lg transition"
                                                        >
                                                            <Plus size={20} className="sm:w-6 sm:h-6" />
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>

                                            <div className="flex gap-2">
                                                <button
                                                    onClick={previousPlayer}
                                                    className="flex-1 bg-white/10 hover:bg-white/20 text-white py-2 sm:py-3 rounded-lg transition text-sm sm:text-base"
                                                >
                                                    â† Previous
                                                </button>
                                                <button
                                                    onClick={nextPlayer}
                                                    className="flex-1 bg-white/10 hover:bg-white/20 text-white py-2 sm:py-3 rounded-lg transition text-sm sm:text-base"
                                                >
                                                    Next â†’
                                                </button>
                                            </div>

                                            {showCamera && (
                                                <div className="space-y-2">
                                                    <div className="flex gap-2">
                                                        {!isRecording ? (
                                                            <button
                                                                onClick={startRecording}
                                                                className="flex-1 bg-red-500 hover:bg-red-600 text-white py-2 sm:py-3 rounded-lg font-bold transition flex items-center justify-center gap-2 text-sm sm:text-base"
                                                            >
                                                                <Video size={16} className="sm:w-5 sm:h-5" />
                                                                Start Recording
                                                            </button>
                                                        ) : (
                                                            <button
                                                                onClick={stopRecording}
                                                                className="flex-1 bg-orange-500 hover:bg-orange-600 text-white py-2 sm:py-3 rounded-lg font-bold transition flex items-center justify-center gap-2 text-sm sm:text-base animate-pulse"
                                                            >
                                                                <div className="w-3 h-3 bg-white rounded-full"></div>
                                                                Stop Recording
                                                            </button>
                                                        )}
                                                        {recordedVideoUrl && (
                                                            <button
                                                                onClick={downloadRecording}
                                                                className="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 sm:py-3 rounded-lg font-bold transition flex items-center justify-center gap-2 text-sm sm:text-base"
                                                            >
                                                                <Download size={16} className="sm:w-5 sm:h-5" />
                                                                Save Video
                                                            </button>
                                                        )}
                                                    </div>
                                                    <button
                                                        onClick={switchCamera}
                                                        className="w-full bg-purple-500 hover:bg-purple-600 text-white py-2 sm:py-3 rounded-lg font-bold transition flex items-center justify-center gap-2 text-sm sm:text-base"
                                                    >
                                                        <RefreshCw size={16} className="sm:w-5 sm:h-5" />
                                                        Switch to {currentFacingMode === 'environment' ? 'Front' : 'Back'} Camera
                                                    </button>
                                                    <button
                                                        onClick={toggleDetection}
                                                        className={`w-full py-2 sm:py-3 rounded-lg font-bold transition text-sm sm:text-base ${
                                                            isDetecting 
                                                                ? 'bg-orange-500 hover:bg-orange-600 text-white' 
                                                                : 'bg-blue-500 hover:bg-blue-600 text-white'
                                                        }`}
                                                    >
                                                        {isDetecting ? 'Pause Auto-Detection' : 'Resume Auto-Detection'}
                                                    </button>
                                                </div>
                                            )}

                                            {!isTracking ? (
                                                <button
                                                    onClick={startTracking}
                                                    className="w-full bg-green-500 hover:bg-green-600 text-white py-3 sm:py-4 rounded-xl font-bold text-base sm:text-lg flex items-center justify-center gap-2 transition"
                                                >
                                                    <Play size={20} className="sm:w-6 sm:h-6" />
                                                    Start Tracking
                                                </button>
                                            ) : (
                                                <button
                                                    onClick={stopTracking}
                                                    className="w-full bg-red-500 hover:bg-red-600 text-white py-3 sm:py-4 rounded-xl font-bold text-base sm:text-lg flex items-center justify-center gap-2 transition"
                                                >
                                                    <Pause size={20} className="sm:w-6 sm:h-6" />
                                                    Stop Tracking
                                                </button>
                                            )}
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Bottom Panel (Mobile) / Right Panel (Desktop) - Players and Leaderboard */}
                            <div className="space-y-4 order-2">
                                <div className="bg-white/10 backdrop-blur-lg rounded-none lg:rounded-2xl p-4 sm:p-6 border-0 lg:border border-white/20">
                                    <h2 className="text-xl sm:text-2xl font-bold text-white mb-4 flex items-center gap-2">
                                        <Users size={20} className="sm:w-6 sm:h-6" />
                                        Add Players
                                    </h2>
                                    
                                    <div className="flex gap-2 mb-4">
                                        <input
                                            type="text"
                                            value={newPlayerName}
                                            onChange={(e) => setNewPlayerName(e.target.value)}
                                            onKeyPress={(e) => e.key === 'Enter' && addPlayer()}
                                            placeholder="Enter player name"
                                            className="flex-1 bg-white/20 border border-white/30 rounded-lg px-3 sm:px-4 py-2 sm:py-3 text-sm sm:text-base text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-blue-400"
                                        />
                                        <button
                                            onClick={addPlayer}
                                            className="bg-blue-500 hover:bg-blue-600 text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg font-bold transition text-sm sm:text-base"
                                        >
                                            Add
                                        </button>
                                    </div>

                                    {players.length > 0 && (
                                        <div className="space-y-2">
                                            <button
                                                onClick={resetScores}
                                                className="w-full bg-orange-500 hover:bg-orange-600 text-white py-2 rounded-lg font-bold transition text-sm sm:text-base"
                                            >
                                                Reset All Scores
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (window.confirm('Are you sure you want to clear all saved player names?')) {
                                                        setPlayers([]);
                                                        clearSavedPlayers();
                                                    }
                                                }}
                                                className="w-full bg-red-500 hover:bg-red-600 text-white py-2 rounded-lg font-bold transition text-sm sm:text-base"
                                            >
                                                Clear All Players
                                            </button>
                                        </div>
                                    )}
                                    
                                    {players.length === 0 && (
                                        <div className="bg-yellow-500/20 border border-yellow-500/50 rounded-lg p-3 sm:p-4 mt-4">
                                            <p className="text-yellow-200 text-xs sm:text-sm text-center">
                                                ðŸ“ <strong>Tip:</strong> Add player names first! They will be saved automatically.
                                            </p>
                                        </div>
                                    )}
                                </div>

                                <div className="bg-white/10 backdrop-blur-lg rounded-none lg:rounded-2xl p-4 sm:p-6 border-0 lg:border border-white/20">
                                    <h2 className="text-xl sm:text-2xl font-bold text-white mb-4 flex items-center gap-2">
                                        <Trophy size={20} className="text-yellow-400 sm:w-6 sm:h-6" />
                                        Leaderboard
                                    </h2>
                                    
                                    {players.length === 0 ? (
                                        <p className="text-white/50 text-center py-6 sm:py-8 text-sm sm:text-base">No players yet. Add some to get started!</p>
                                    ) : (
                                        <div className="space-y-2">
                                            {sortedPlayers.map((player, index) => {
                                                const originalIndex = players.findIndex(p => p.name === player.name);
                                                const isCurrentPlayer = originalIndex === currentPlayerIndex;
                                                
                                                return (
                                                    <div
                                                        key={player.name}
                                                        className={`p-3 sm:p-4 rounded-xl flex items-center justify-between transition ${
                                                            isCurrentPlayer 
                                                                ? 'bg-gradient-to-r from-blue-500 to-purple-500 ring-2 ring-yellow-400' 
                                                                : 'bg-white/10 hover:bg-white/20'
                                                        }`}
                                                    >
                                                        <div className="flex items-center gap-3 sm:gap-4">
                                                            <div className={`w-7 h-7 sm:w-8 sm:h-8 rounded-full flex items-center justify-center font-bold text-sm sm:text-base ${
                                                                index === 0 ? 'bg-yellow-400 text-black' :
                                                                index === 1 ? 'bg-gray-300 text-black' :
                                                                index === 2 ? 'bg-orange-400 text-black' :
                                                                'bg-white/20 text-white'
                                                            }`}>
                                                                {index + 1}
                                                            </div>
                                                            <div>
                                                                <p className="text-white font-bold text-sm sm:text-base">{player.name}</p>
                                                                {isCurrentPlayer && (
                                                                    <p className="text-xs text-yellow-300">Currently performing</p>
                                                                )}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2 sm:gap-3">
                                                            <span className="text-xl sm:text-2xl font-bold text-white">{player.score}</span>
                                                            <button
                                                                onClick={() => removePlayer(originalIndex)}
                                                                className="text-red-400 hover:text-red-300 transition text-lg sm:text-xl"
                                                            >
                                                                âœ•
                                                            </button>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {/* Version and Last Update Info */}
                    <div className="text-center px-4 py-6">
                        <p className="text-xs text-white/40">
                            Version 1.0.0 | Last Updated: November 2, 2025
                        </p>
                    </div>
                </div>
            );
        }

        // Render the app using React 18 createRoot API
        if (ReactDOM.createRoot) {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<PullUpTracker />);
        } else {
            // Fallback for older React versions
            ReactDOM.render(<PullUpTracker />, document.getElementById('root'));
        }
    </script>
</body>
</html>